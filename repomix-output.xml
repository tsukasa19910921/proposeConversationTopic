This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/settings.local.json
.gitignore
CLAUDE.md
DEPLOYMENT_FIX.md
next.config.js
package.json
postcss.config.js
prisma/schema.prisma
src/app/api/auth/login/route.ts
src/app/api/auth/logout/route.ts
src/app/api/auth/signup/route.ts
src/app/api/metrics/me/route.ts
src/app/api/profile/me/route.ts
src/app/api/qr/me/route.ts
src/app/api/scan/route.ts
src/app/auth/login/page.tsx
src/app/auth/signup/page.tsx
src/app/globals.css
src/app/home/page.tsx
src/app/layout.tsx
src/app/metrics/page.tsx
src/app/page.tsx
src/app/profile/page.tsx
src/components/CameraScanner.tsx
src/components/Navigation.tsx
src/components/Toast.tsx
src/components/TopicModal.tsx
src/lib/cooldown.ts
src/lib/db.ts
src/lib/llm.ts
src/lib/qr.ts
src/lib/repos/counters.ts
src/lib/repos/profile.ts
src/lib/repos/users.ts
src/lib/session.ts
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(npm run dev:*)",
      "Bash(curl:*)",
      "Bash(npm install:*)",
      "Bash(npx prisma generate:*)",
      "Bash(npx prisma:*)",
      "Bash(tasklist)",
      "Bash(taskkill:*)",
      "Bash(cp:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path=".gitignore">
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="DEPLOYMENT_FIX.md">
# Vercelデプロイ500エラー修正ガイド

## 1. 完了した修正
✅ すべてのAPIルートハンドラーに動的実行設定を追加しました
- cookies()を使用するため静的プリレンダができないエラーを解決

## 2. Vercel環境変数チェックリスト

### 必須の環境変数
以下の環境変数をVercelのダッシュボードで設定してください：

1. **DATABASE_URL** (必須)
   - PostgreSQLの接続文字列
   - 例: `postgresql://user:password@host:5432/dbname?sslmode=require`
   - Supabase/Neonの無料プランでOK

2. **SESSION_SECRET** (必須)
   - ランダムな長い文字列（32文字以上推奨）
   - 未設定だとCookie署名でエラー→500エラーの原因
   - 生成例: `openssl rand -hex 32`

3. **APP_BASE_URL** (必須)
   - 本番環境のURL
   - 例: `https://your-app-name.vercel.app`
   - QRコード生成で使用

4. **GOOGLE_GEMINI_API_KEY** (必須)
   - Google AI StudioからGemini APIキーを取得
   - https://makersuite.google.com/app/apikey

5. **SESSION_MAX_AGE_SECONDS** (任意)
   - デフォルト: 86400 (24時間)

### 設定手順
1. Vercelダッシュボードへログイン
2. プロジェクトを選択
3. Settings → Environment Variables
4. 各環境変数を追加（Production/Preview/Development全てにチェック）
5. Save

## 3. データベースの初期化

### Supabaseを使用する場合：
```bash
# ローカルで実行
npx prisma db push
```

または、Vercelのビルドステップで自動実行されます（package.jsonのbuildスクリプト）

## 4. 再デプロイ
環境変数を設定したら、再デプロイを実行：
```bash
vercel --prod
```

## 5. 動作確認

### APIエンドポイントテスト
```bash
# サインアップテスト
curl -X POST https://your-app.vercel.app/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{"userId":"test1","password":"password123"}'

# レスポンス例（成功）
# {"ok":true}
# Set-Cookie: sid=...
```

### ブラウザでの確認
1. `/auth/signup`でユーザー作成
2. `/home`で自分のQR表示確認
3. `/metrics`で実績表示確認

## 6. トラブルシューティング

### 500エラーが続く場合
- Vercelの Functions ログを確認
- 環境変数が正しく設定されているか再確認
- DATABASE_URLの接続文字列が正しいか確認

### "Dynamic server usage"エラーが出る場合
- すべてのAPIルートに`export const dynamic = 'force-dynamic'`があるか確認
- 再デプロイを実行

### favicon.ico 404エラー
- `/public/favicon.ico`を追加（任意）
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="src/app/auth/login/page.tsx">
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import Link from 'next/link'

export default function LoginPage() {
  const [userId, setUserId] = useState('')
  const [password, setPassword] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState('')
  const router = useRouter()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError('')

    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ userId, password }),
      })

      const data = await response.json()

      if (response.ok) {
        router.push('/home')
      } else {
        setError(data.error === 'invalid_credentials' ? 'ユーザーIDまたはパスワードが正しくありません' : 'ログインに失敗しました')
      }
    } catch (error) {
      setError('ネットワークエラーが発生しました')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="max-w-md mx-auto p-4">
      <div className="text-center mb-8">
        <h1 className="text-2xl font-bold text-gray-800 mb-2">ログイン</h1>
        <p className="text-gray-600">アカウントにサインインしてください</p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="userId" className="block text-sm font-medium text-gray-700 mb-1">
            ユーザーID
          </label>
          <input
            type="text"
            id="userId"
            value={userId}
            onChange={(e) => setUserId(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            required
            disabled={isLoading}
          />
        </div>

        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700 mb-1">
            パスワード
          </label>
          <input
            type="password"
            id="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            required
            disabled={isLoading}
          />
        </div>

        {error && (
          <div className="text-red-600 text-sm text-center bg-red-50 p-2 rounded-lg">
            {error}
          </div>
        )}

        <button
          type="submit"
          disabled={isLoading}
          className="w-full py-2 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isLoading ? 'ログイン中...' : 'ログイン'}
        </button>
      </form>

      <div className="mt-6 text-center">
        <p className="text-gray-600">
          アカウントをお持ちでない場合{' '}
          <Link href="/auth/signup" className="text-blue-500 hover:text-blue-600 font-medium">
            新規登録
          </Link>
        </p>
      </div>
    </div>
  )
}
</file>

<file path="src/app/auth/signup/page.tsx">
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import Link from 'next/link'

export default function SignupPage() {
  const [userId, setUserId] = useState('')
  const [password, setPassword] = useState('')
  const [confirmPassword, setConfirmPassword] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState('')
  const router = useRouter()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError('')

    if (password !== confirmPassword) {
      setError('パスワードが一致しません')
      return
    }

    if (password.length < 6) {
      setError('パスワードは6文字以上で入力してください')
      return
    }

    setIsLoading(true)

    try {
      const response = await fetch('/api/auth/signup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ userId, password }),
      })

      const data = await response.json()

      if (response.ok) {
        router.push('/home')
      } else {
        setError(data.error === 'user_exists' ? 'このユーザーIDは既に使用されています' : '新規登録に失敗しました')
      }
    } catch (error) {
      setError('ネットワークエラーが発生しました')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="max-w-md mx-auto p-4">
      <div className="text-center mb-8">
        <h1 className="text-2xl font-bold text-gray-800 mb-2">新規登録</h1>
        <p className="text-gray-600">新しいアカウントを作成してください</p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="userId" className="block text-sm font-medium text-gray-700 mb-1">
            ユーザーID
          </label>
          <input
            type="text"
            id="userId"
            value={userId}
            onChange={(e) => setUserId(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent"
            required
            disabled={isLoading}
            minLength={3}
          />
          <p className="text-xs text-gray-500 mt-1">3文字以上で入力してください</p>
        </div>

        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700 mb-1">
            パスワード
          </label>
          <input
            type="password"
            id="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent"
            required
            disabled={isLoading}
            minLength={6}
          />
          <p className="text-xs text-gray-500 mt-1">6文字以上で入力してください</p>
        </div>

        <div>
          <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700 mb-1">
            パスワード確認
          </label>
          <input
            type="password"
            id="confirmPassword"
            value={confirmPassword}
            onChange={(e) => setConfirmPassword(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent"
            required
            disabled={isLoading}
          />
        </div>

        {error && (
          <div className="text-red-600 text-sm text-center bg-red-50 p-2 rounded-lg">
            {error}
          </div>
        )}

        <button
          type="submit"
          disabled={isLoading}
          className="w-full py-2 px-4 bg-green-500 text-white rounded-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isLoading ? '登録中...' : '新規登録'}
        </button>
      </form>

      <div className="mt-6 text-center">
        <p className="text-gray-600">
          既にアカウントをお持ちの場合{' '}
          <Link href="/auth/login" className="text-blue-500 hover:text-blue-600 font-medium">
            ログイン
          </Link>
        </p>
      </div>
    </div>
  )
}
</file>

<file path="src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* QR Scanner Animation */
@keyframes scan {
  0% {
    top: 0;
  }
  50% {
    top: calc(100% - 4px);
  }
  100% {
    top: 0;
  }
}

.animate-scan {
  animation: scan 2s ease-in-out infinite;
}
</file>

<file path="src/app/home/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import Navigation from '@/components/Navigation'
import TopicModal from '@/components/TopicModal'
import Toast from '@/components/Toast'
import CameraScanner from '@/components/CameraScanner'

export default function HomePage() {
  const [qrData, setQrData] = useState<{ url: string; svg: string } | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [topic, setTopic] = useState<string>('')
  const [showTopicModal, setShowTopicModal] = useState(false)
  const [showScanner, setShowScanner] = useState(false)
  const [toast, setToast] = useState<{ message: string; type: 'success' | 'error' | 'warning'; isVisible: boolean }>({
    message: '',
    type: 'success',
    isVisible: false
  })
  const router = useRouter()

  useEffect(() => {
    fetchQR()
  }, [])

  const fetchQR = async () => {
    try {
      const response = await fetch('/api/qr/me')

      if (response.status === 401) {
        router.push('/auth/login')
        return
      }

      if (response.ok) {
        const data = await response.json()
        setQrData(data)
      } else {
        showToast('QRコードの取得に失敗しました', 'error')
      }
    } catch (error) {
      showToast('ネットワークエラーが発生しました', 'error')
    } finally {
      setIsLoading(false)
    }
  }

  const showToast = (message: string, type: 'success' | 'error' | 'warning') => {
    setToast({ message, type, isVisible: true })
  }

  const hideToast = () => {
    setToast(prev => ({ ...prev, isVisible: false }))
  }

  const handleScanResult = async (scannedSid: string) => {
    try {
      const response = await fetch('/api/scan', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ scannedSid }),
      })

      const data = await response.json()

      if (response.ok) {
        setTopic(data.message)
        setShowTopicModal(true)
        showToast('スキャン成功！', 'success')
      } else if (response.status === 429) {
        showToast(data.message || '時間をおいてトライしてください', 'warning')
      } else if (response.status === 401) {
        router.push('/auth/login')
      } else if (response.status === 400 && data.error === 'self_scan') {
        showToast('自分のQRコードはスキャンできません', 'warning')
      } else if (response.status === 404) {
        showToast('ユーザーが見つかりませんでした', 'error')
      } else {
        showToast('スキャンに失敗しました', 'error')
      }
    } catch (error) {
      showToast('ネットワークエラーが発生しました', 'error')
    }
  }

  const handleLogout = async () => {
    try {
      await fetch('/api/auth/logout', { method: 'POST' })
      router.push('/')
    } catch (error) {
      showToast('ログアウトに失敗しました', 'error')
    }
  }

  if (isLoading) {
    return (
      <div className="max-w-md mx-auto p-4 pb-20 min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
          <p className="text-gray-600">読み込み中...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="max-w-md mx-auto p-4 pb-20 min-h-screen">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-xl font-bold text-gray-800">ホーム</h1>
        <button
          onClick={handleLogout}
          className="text-sm text-gray-600 hover:text-gray-800"
        >
          ログアウト
        </button>
      </div>

      {/* QRコード表示 */}
      <div className="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 className="text-lg font-semibold text-gray-800 mb-4 text-center">
          あなたのQRコード
        </h2>
        {qrData ? (
          <div className="flex justify-center">
            <div
              className="w-48 h-48 border border-gray-200 rounded-lg p-2"
              dangerouslySetInnerHTML={{ __html: qrData.svg }}
            />
          </div>
        ) : (
          <div className="flex justify-center">
            <div className="w-48 h-48 border border-gray-200 rounded-lg flex items-center justify-center bg-gray-50">
              <span className="text-gray-400">QRコード読み込み中...</span>
            </div>
          </div>
        )}
        <p className="text-xs text-gray-500 text-center mt-2">
          このQRコードを相手に読み取ってもらいましょう
        </p>
      </div>

      {/* スキャンボタン */}
      <div className="space-y-3">
        <button
          onClick={() => setShowScanner(true)}
          className="w-full py-3 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 text-lg font-medium"
        >
          📱 相手のQRを読み取る
        </button>
      </div>

      {/* ナビゲーション */}
      <Navigation />

      {/* カメラスキャナー */}
      <CameraScanner
        isOpen={showScanner}
        onClose={() => setShowScanner(false)}
        onScan={handleScanResult}
      />

      {/* モーダル */}
      <TopicModal
        isOpen={showTopicModal}
        message={topic}
        onClose={() => setShowTopicModal(false)}
      />

      {/* トースト */}
      <Toast
        message={toast.message}
        type={toast.type}
        isVisible={toast.isVisible}
        onClose={hideToast}
      />
    </div>
  )
}
</file>

<file path="src/app/layout.tsx">
import './globals.css'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: 'QRプロフィール×話題提示',
  description: '高校生向けQR交換アプリ',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ja">
      <body className={inter.className}>
        <main className="min-h-screen bg-gray-50">
          {children}
        </main>
      </body>
    </html>
  )
}
</file>

<file path="src/app/metrics/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import Navigation from '@/components/Navigation'
import Toast from '@/components/Toast'

interface MetricsData {
  scanOut: number
  scanIn: number
}

export default function MetricsPage() {
  const [metrics, setMetrics] = useState<MetricsData>({ scanOut: 0, scanIn: 0 })
  const [isLoading, setIsLoading] = useState(true)
  const [toast, setToast] = useState<{ message: string; type: 'success' | 'error' | 'warning'; isVisible: boolean }>({
    message: '',
    type: 'success',
    isVisible: false
  })
  const router = useRouter()

  useEffect(() => {
    fetchMetrics()
  }, [])

  const fetchMetrics = async () => {
    try {
      const response = await fetch('/api/metrics/me')

      if (response.status === 401) {
        router.push('/auth/login')
        return
      }

      if (response.ok) {
        const data = await response.json()
        setMetrics(data)
      } else {
        showToast('実績の取得に失敗しました', 'error')
      }
    } catch (error) {
      showToast('ネットワークエラーが発生しました', 'error')
    } finally {
      setIsLoading(false)
    }
  }

  const showToast = (message: string, type: 'success' | 'error' | 'warning') => {
    setToast({ message, type, isVisible: true })
  }

  const hideToast = () => {
    setToast(prev => ({ ...prev, isVisible: false }))
  }

  if (isLoading) {
    return (
      <div className="max-w-md mx-auto p-4 pb-20 min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
          <p className="text-gray-600">読み込み中...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="max-w-md mx-auto p-4 pb-20 min-h-screen">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-xl font-bold text-gray-800">実績</h1>
        <button
          onClick={fetchMetrics}
          className="text-sm text-blue-500 hover:text-blue-600"
        >
          更新
        </button>
      </div>

      {/* 実績カード */}
      <div className="space-y-4">
        {/* 読み取り回数 */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <div className="flex items-center justify-between">
            <div>
              <div className="flex items-center space-x-2 mb-2">
                <span className="text-2xl">📱</span>
                <h2 className="text-lg font-semibold text-gray-800">読み取り回数</h2>
              </div>
              <p className="text-sm text-gray-600">
                あなたが他の人のQRコードを読み取った回数
              </p>
            </div>
            <div className="text-right">
              <div className="text-3xl font-bold text-blue-500">{metrics.scanOut}</div>
              <div className="text-sm text-gray-500">回</div>
            </div>
          </div>
        </div>

        {/* 読み取られ回数 */}
        <div className="bg-white rounded-lg shadow-md p-6">
          <div className="flex items-center justify-between">
            <div>
              <div className="flex items-center space-x-2 mb-2">
                <span className="text-2xl">✨</span>
                <h2 className="text-lg font-semibold text-gray-800">読み取られ回数</h2>
              </div>
              <p className="text-sm text-gray-600">
                他の人があなたのQRコードを読み取った回数
              </p>
            </div>
            <div className="text-right">
              <div className="text-3xl font-bold text-green-500">{metrics.scanIn}</div>
              <div className="text-sm text-gray-500">回</div>
            </div>
          </div>
        </div>

        {/* 総合実績 */}
        <div className="bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg shadow-md p-6 text-white">
          <div className="text-center">
            <div className="text-2xl mb-2">🏆</div>
            <h2 className="text-lg font-semibold mb-2">総合実績</h2>
            <div className="text-2xl font-bold mb-1">
              {metrics.scanOut + metrics.scanIn}
            </div>
            <div className="text-sm opacity-90">
              総交流回数
            </div>
            <div className="mt-4 text-xs opacity-75">
              QRコードを通じて{metrics.scanOut + metrics.scanIn}回の出会いがありました！
            </div>
          </div>
        </div>

        {/* メッセージ */}
        <div className="text-center">
          {metrics.scanOut + metrics.scanIn === 0 ? (
            <p className="text-gray-500 text-sm">
              まだ交流がありません。<br />
              ホーム画面からQRコードを読み取って、<br />
              新しい出会いを始めましょう！
            </p>
          ) : (
            <p className="text-gray-500 text-sm">
              素晴らしい交流実績です！<br />
              引き続き新しい出会いを楽しんでください。
            </p>
          )}
        </div>
      </div>

      {/* ナビゲーション */}
      <Navigation />

      {/* トースト */}
      <Toast
        message={toast.message}
        type={toast.type}
        isVisible={toast.isVisible}
        onClose={hideToast}
      />
    </div>
  )
}
</file>

<file path="src/app/page.tsx">
'use client'

import { useState } from 'react'
import Link from 'next/link'

export default function HomePage() {
  const [isLoggedIn, setIsLoggedIn] = useState(false)

  return (
    <div className="max-w-md mx-auto p-4">
      <div className="text-center mb-8">
        <h1 className="text-2xl font-bold text-gray-800 mb-2">
          QRプロフィール×話題提示
        </h1>
        <p className="text-gray-600">
          QRコードを交換して、会話のきっかけを見つけよう！
        </p>
      </div>

      {!isLoggedIn ? (
        <div className="space-y-4">
          <Link
            href="/auth/login"
            className="block w-full py-3 px-4 bg-blue-500 text-white text-center rounded-lg hover:bg-blue-600 transition-colors"
          >
            ログイン
          </Link>
          <Link
            href="/auth/signup"
            className="block w-full py-3 px-4 bg-green-500 text-white text-center rounded-lg hover:bg-green-600 transition-colors"
          >
            新規登録
          </Link>
        </div>
      ) : (
        <div className="text-center">
          <p className="text-gray-600 mb-4">ログイン済み</p>
          <Link
            href="/home"
            className="inline-block py-2 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
          >
            ホームに進む
          </Link>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/app/profile/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import Navigation from '@/components/Navigation'
import Toast from '@/components/Toast'

const TOPICS = {
  sports: {
    label: 'スポーツ',
    icon: '⚽',
    options: ['野球', 'サッカー', '卓球', 'テニス', 'バスケットボール', 'バレーボール', 'ゴルフ', 'その他']
  },
  music: {
    label: '音楽',
    icon: '🎵',
    options: ['J-POP', 'K-POP', 'ロック', 'ジャズ', 'クラシック', 'アニソン', 'ボカロ', 'その他']
  },
  food: {
    label: '食事',
    icon: '🍕',
    options: ['和食', '洋食', '中華', 'イタリアン', 'ファストフード', 'お菓子作り', 'カフェ', 'その他']
  },
  movies: {
    label: '映画・ドラマ',
    icon: '🎬',
    options: ['邦画', '洋画', '韓国ドラマ', 'アニメ', 'ドキュメンタリー', 'コメディ', 'ホラー', 'その他']
  },
  games: {
    label: 'ゲーム',
    icon: '🎮',
    options: ['RPG', 'アクション', 'パズル', 'シミュレーション', 'FPS', 'モバイルゲーム', 'ボードゲーム', 'その他']
  },
  books: {
    label: '読書',
    icon: '📚',
    options: ['小説', '漫画', 'ライトノベル', 'ビジネス書', '自己啓発', '歴史', '科学', 'その他']
  }
}

interface ProfileData {
  [topicId: string]: {
    [option: string]: {
      selected: boolean
      freeText: string
    }
  }
}

export default function ProfilePage() {
  const [profile, setProfile] = useState<ProfileData>({})
  const [expandedTopics, setExpandedTopics] = useState<Set<string>>(new Set())
  const [isLoading, setIsLoading] = useState(true)
  const [isSaving, setIsSaving] = useState(false)
  const [toast, setToast] = useState<{ message: string; type: 'success' | 'error' | 'warning'; isVisible: boolean }>({
    message: '',
    type: 'success',
    isVisible: false
  })
  const router = useRouter()

  useEffect(() => {
    fetchProfile()
  }, [])

  const initializeProfileStructure = () => {
    const initialProfile: ProfileData = {}
    Object.keys(TOPICS).forEach(topicId => {
      initialProfile[topicId] = {}
      TOPICS[topicId as keyof typeof TOPICS].options.forEach(option => {
        initialProfile[topicId][option] = {
          selected: false,
          freeText: ''
        }
      })
    })
    return initialProfile
  }

  const fetchProfile = async () => {
    try {
      const response = await fetch('/api/profile/me')

      if (response.status === 401) {
        router.push('/auth/login')
        return
      }

      if (response.ok) {
        const data = await response.json()
        const initialProfile = initializeProfileStructure()

        if (data && Object.keys(data).length > 0) {
          Object.keys(data).forEach(topicId => {
            if (initialProfile[topicId] && data[topicId]) {
              Object.keys(data[topicId]).forEach(option => {
                if (initialProfile[topicId][option]) {
                  initialProfile[topicId][option] = {
                    selected: data[topicId][option]?.selected || false,
                    freeText: data[topicId][option]?.freeText || ''
                  }
                }
              })
            }
          })
        }

        setProfile(initialProfile)
      } else {
        setProfile(initializeProfileStructure())
      }
    } catch (error) {
      showToast('プロフィールの取得に失敗しました', 'error')
      setProfile(initializeProfileStructure())
    } finally {
      setIsLoading(false)
    }
  }

  const showToast = (message: string, type: 'success' | 'error' | 'warning') => {
    setToast({ message, type, isVisible: true })
  }

  const hideToast = () => {
    setToast(prev => ({ ...prev, isVisible: false }))
  }

  const handleOptionToggle = (topicId: string, option: string) => {
    setProfile(prev => ({
      ...prev,
      [topicId]: {
        ...prev[topicId],
        [option]: {
          ...prev[topicId][option],
          selected: !prev[topicId][option].selected
        }
      }
    }))
  }

  const handleFreeTextChange = (topicId: string, option: string, value: string) => {
    setProfile(prev => ({
      ...prev,
      [topicId]: {
        ...prev[topicId],
        [option]: {
          ...prev[topicId][option],
          freeText: value
        }
      }
    }))
  }

  const toggleTopic = (topicId: string) => {
    setExpandedTopics(prev => {
      const newSet = new Set(prev)
      if (newSet.has(topicId)) {
        newSet.delete(topicId)
      } else {
        newSet.add(topicId)
      }
      return newSet
    })
  }

  const hasSelectedOptions = (topicId: string) => {
    return Object.values(profile[topicId] || {}).some(option => option.selected)
  }

  const handleSave = async () => {
    setIsSaving(true)

    try {
      const response = await fetch('/api/profile/me', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(profile),
      })

      if (response.status === 401) {
        router.push('/auth/login')
        return
      }

      if (response.ok) {
        showToast('プロフィールを保存しました', 'success')
      } else {
        showToast('保存に失敗しました', 'error')
      }
    } catch (error) {
      showToast('ネットワークエラーが発生しました', 'error')
    } finally {
      setIsSaving(false)
    }
  }

  if (isLoading) {
    return (
      <div className="max-w-md mx-auto p-4 pb-20 min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
          <p className="text-gray-600">読み込み中...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="max-w-md mx-auto p-4 pb-20 min-h-screen">
      <h1 className="text-xl font-bold text-gray-800 mb-6">プロフィール設定</h1>

      <div className="space-y-4">
        {Object.entries(TOPICS).map(([topicId, topic]) => {
          const isExpanded = expandedTopics.has(topicId)
          const hasSelections = hasSelectedOptions(topicId)

          return (
            <div key={topicId} className="bg-white rounded-lg shadow-md overflow-hidden">
              {/* トピックヘッダー（クリック可能） */}
              <button
                onClick={() => toggleTopic(topicId)}
                className="w-full p-4 flex items-center justify-between hover:bg-gray-50 transition-colors"
              >
                <div className="flex items-center space-x-3">
                  <span className="text-2xl">{topic.icon}</span>
                  <h2 className="text-lg font-semibold text-gray-800">{topic.label}</h2>
                  {hasSelections && (
                    <div className="w-2 h-2 bg-blue-500 rounded-full"></div>
                  )}
                </div>
                <div className="flex items-center space-x-2">
                  {hasSelections && (
                    <span className="text-xs text-blue-600 font-medium">
                      {Object.values(profile[topicId] || {}).filter(option => option.selected).length}件選択中
                    </span>
                  )}
                  <svg
                    className={`w-5 h-5 text-gray-500 transition-transform duration-200 ${
                      isExpanded ? 'rotate-180' : ''
                    }`}
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                  </svg>
                </div>
              </button>

              {/* 選択肢（展開時のみ表示） */}
              {isExpanded && (
                <div className="px-4 pb-4 space-y-3 border-t border-gray-100 pt-4">
                  {topic.options.map((option) => (
                    <div key={option} className="space-y-2">
                      {/* チェックボックス */}
                      <label className="flex items-center space-x-3 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={profile[topicId]?.[option]?.selected || false}
                          onChange={() => handleOptionToggle(topicId, option)}
                          className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2"
                        />
                        <span className="text-gray-700">{option}</span>
                      </label>

                      {/* 自由入力欄（選択時のみ表示） */}
                      {profile[topicId]?.[option]?.selected && (
                        <div className="ml-7">
                          <textarea
                            value={profile[topicId][option].freeText}
                            onChange={(e) => handleFreeTextChange(topicId, option, e.target.value)}
                            placeholder={`${option}について詳しく教えてください...`}
                            className="w-full h-20 px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none bg-blue-50"
                            maxLength={100}
                          />
                          <p className="text-xs text-gray-500 mt-1 text-right">
                            {profile[topicId][option].freeText.length}/100文字
                          </p>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )
        })}
      </div>

      {/* 保存ボタン */}
      <div className="mt-6">
        <button
          onClick={handleSave}
          disabled={isSaving}
          className="w-full py-3 px-4 bg-green-500 text-white rounded-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isSaving ? '保存中...' : '保存する'}
        </button>
      </div>

      {/* ナビゲーション */}
      <Navigation />

      {/* トースト */}
      <Toast
        message={toast.message}
        type={toast.type}
        isVisible={toast.isVisible}
        onClose={hideToast}
      />
    </div>
  )
}
</file>

<file path="src/components/CameraScanner.tsx">
'use client';

import { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';

// Dynamic import to avoid SSR issues - using Scanner instead of QrScanner
const Scanner = dynamic(
  () => import('@yudiel/react-qr-scanner').then((mod) => mod.Scanner),
  {
    ssr: false,
    loading: () => (
      <div className="flex items-center justify-center h-full">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      </div>
    )
  }
);

interface CameraScannerProps {
  isOpen: boolean;
  onClose: () => void;
  onScan: (data: string) => void;
}

export default function CameraScanner({ isOpen, onClose, onScan }: CameraScannerProps) {
  const [hasPermission, setHasPermission] = useState<boolean | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (isOpen) {
      // Reset states when scanner opens
      setError(null);
      setHasPermission(null);

      // Request camera permission
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(() => setHasPermission(true))
        .catch(() => {
          setHasPermission(false);
          setError('カメラへのアクセスが許可されていません');
        });
    }
  }, [isOpen]);

  if (!isOpen) return null;

  const handleDecode = (result: string) => {
    // Parse the QR code URL to extract sid
    try {
      const url = new URL(result);
      const sid = url.searchParams.get('sid');
      if (sid) {
        onScan(sid);
        onClose();
      } else {
        setError('無効なQRコードです');
      }
    } catch {
      // Handle non-URL QR codes
      setError('無効なQRコードです');
    }
  };

  const handleError = (error: any) => {
    console.error('QR Scanner Error:', error);
    setError('スキャン中にエラーが発生しました');
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-90 flex flex-col z-50">
      <div className="bg-white text-black p-4 flex justify-between items-center">
        <h2 className="text-xl font-semibold">QRコードをスキャン</h2>
        <button
          onClick={onClose}
          className="text-gray-600 hover:text-gray-800 text-2xl"
        >
          ✕
        </button>
      </div>

      <div className="flex-1 relative">
        {hasPermission === false ? (
          <div className="flex flex-col items-center justify-center h-full text-white p-4">
            <svg
              className="w-24 h-24 mb-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
              />
            </svg>
            <p className="text-center mb-4">カメラへのアクセスが拒否されました</p>
            <p className="text-sm text-gray-300 text-center">
              ブラウザの設定からカメラへのアクセスを許可してください
            </p>
          </div>
        ) : hasPermission === null ? (
          <div className="flex flex-col items-center justify-center h-full text-white">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mb-4"></div>
            <p>カメラの許可を確認中...</p>
          </div>
        ) : (
          <>
            <Scanner
              onScan={(result) => {
                if (result && result.length > 0) {
                  handleDecode(result[0].rawValue);
                }
              }}
              onError={handleError}
              constraints={{
                facingMode: { ideal: 'environment' }
              }}
              styles={{
                container: {
                  width: '100%',
                  height: '100%'
                },
                video: {
                  width: '100%',
                  height: '100%',
                  objectFit: 'cover' as const
                }
              }}
            />

            {/* Scanning overlay */}
            <div className="absolute inset-0 pointer-events-none">
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="relative w-64 h-64">
                  {/* Corner markers */}
                  <div className="absolute top-0 left-0 w-12 h-12 border-t-4 border-l-4 border-white rounded-tl-lg"></div>
                  <div className="absolute top-0 right-0 w-12 h-12 border-t-4 border-r-4 border-white rounded-tr-lg"></div>
                  <div className="absolute bottom-0 left-0 w-12 h-12 border-b-4 border-l-4 border-white rounded-bl-lg"></div>
                  <div className="absolute bottom-0 right-0 w-12 h-12 border-b-4 border-r-4 border-white rounded-br-lg"></div>

                  {/* Scanning line animation */}
                  <div className="absolute inset-x-0 h-1 bg-gradient-to-r from-transparent via-blue-400 to-transparent animate-scan"></div>
                </div>
              </div>

              {/* Instructions */}
              <div className="absolute bottom-20 left-0 right-0 text-center text-white">
                <p className="text-lg">QRコードを枠内に合わせてください</p>
              </div>
            </div>
          </>
        )}

        {error && (
          <div className="absolute top-20 left-4 right-4 bg-red-500 text-white p-4 rounded-lg">
            <p>{error}</p>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/Navigation.tsx">
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'

export default function Navigation() {
  const pathname = usePathname()

  const navItems = [
    { href: '/home', label: 'ホーム', icon: '🏠' },
    { href: '/profile', label: 'プロフィール', icon: '👤' },
    { href: '/metrics', label: '実績', icon: '📊' },
  ]

  return (
    <nav className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200">
      <div className="max-w-md mx-auto">
        <div className="flex justify-around">
          {navItems.map((item) => (
            <Link
              key={item.href}
              href={item.href}
              className={`flex flex-col items-center py-2 px-4 text-xs ${
                pathname === item.href
                  ? 'text-blue-500'
                  : 'text-gray-600 hover:text-gray-800'
              }`}
            >
              <span className="text-xl mb-1">{item.icon}</span>
              <span>{item.label}</span>
            </Link>
          ))}
        </div>
      </div>
    </nav>
  )
}
</file>

<file path="src/components/Toast.tsx">
'use client'

import { useEffect } from 'react'

interface ToastProps {
  message: string
  type: 'success' | 'error' | 'warning'
  isVisible: boolean
  onClose: () => void
}

export default function Toast({ message, type, isVisible, onClose }: ToastProps) {
  useEffect(() => {
    if (isVisible) {
      const timer = setTimeout(() => {
        onClose()
      }, 3000)
      return () => clearTimeout(timer)
    }
  }, [isVisible, onClose])

  if (!isVisible) return null

  const bgColor = {
    success: 'bg-green-500',
    error: 'bg-red-500',
    warning: 'bg-yellow-500',
  }[type]

  const icon = {
    success: '✅',
    error: '❌',
    warning: '⏳',
  }[type]

  return (
    <div className="fixed top-4 left-1/2 transform -translate-x-1/2 z-50">
      <div className={`${bgColor} text-white px-4 py-2 rounded-lg shadow-lg flex items-center space-x-2`}>
        <span>{icon}</span>
        <span>{message}</span>
      </div>
    </div>
  )
}
</file>

<file path="src/components/TopicModal.tsx">
'use client'

interface TopicModalProps {
  isOpen: boolean
  message: string
  onClose: () => void
}

export default function TopicModal({ isOpen, message, onClose }: TopicModalProps) {
  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg max-w-md w-full p-6">
        <div className="text-center">
          <div className="text-4xl mb-4">💬</div>
          <h2 className="text-xl font-bold text-gray-800 mb-4">会話の話題</h2>
          <p className="text-gray-700 mb-6 leading-relaxed">{message}</p>
          <button
            onClick={onClose}
            className="w-full py-2 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
          >
            閉じる
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/lib/cooldown.ts">
const mem = new Map<string, number>();
const WINDOW = 30_000; // 30 seconds

export async function canScan(scannerId: string, scannedId: string) {
  const key = `${scannerId}:${scannedId}`;
  const now = Date.now();
  const last = mem.get(key) ?? 0;

  if (now - last < WINDOW) {
    return { ok: false, waitMs: WINDOW - (now - last) };
  }

  mem.set(key, now);
  return { ok: true };
}

setInterval(() => {
  const now = Date.now();
  for (const [key, time] of mem.entries()) {
    if (now - time > WINDOW) {
      mem.delete(key);
    }
  }
}, WINDOW);
</file>

<file path="src/lib/db.ts">
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
</file>

<file path="src/lib/llm.ts">
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_GEMINI_API_KEY!);
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

const SYSTEM = `あなたは高校生の初対面の会話を助けるアシスタントです。
安全第一（政治/宗教/性/病気/金銭/個人特定は扱わない）。
出力は敬体で1〜2文、最後は質問で終える。出力は1件のみ。`;

export async function generateTopic(profileA: any, profileB: any): Promise<string> {
  try {
    const prompt = [
      { role: "user", parts: [{ text: SYSTEM }] },
      {
        role: "user",
        parts: [{
          text: `A=${JSON.stringify(profileA)}\nB=${JSON.stringify(profileB)}\n出力は {"message":"..."} 形式で。`
        }]
      },
    ];

    const result = await model.generateContent({ contents: prompt });
    const response = result.response;
    const text = response.text().trim();

    try {
      const parsed = JSON.parse(text);
      return parsed.message || "音楽はよく聴きますか？最近のお気に入りがあれば教えてください。";
    } catch {
      return "音楽はよく聴きますか？最近のお気に入りがあれば教えてください。";
    }
  } catch (error) {
    console.error("LLM generation error:", error);
    return "音楽はよく聴きますか？最近のお気に入りがあれば教えてください。";
  }
}
</file>

<file path="src/lib/qr.ts">
import QRCode from "qrcode";

export async function generateQR(url: string): Promise<string> {
  try {
    const svg = await QRCode.toString(url, {
      type: "svg",
      errorCorrectionLevel: "M",
      margin: 0,
    });
    return svg;
  } catch (error) {
    console.error("QR generation error:", error);
    throw new Error("Failed to generate QR code");
  }
}
</file>

<file path="src/lib/repos/counters.ts">
import { prisma } from "@/lib/db";

export async function getCounters(userId: string) {
  const counters = await prisma.counters.findUnique({
    where: { userId },
  });

  return {
    scanOut: counters?.scanOutCount ?? 0,
    scanIn: counters?.scanInCount ?? 0,
  };
}

export async function incrScanOutIn(scannerId: string, scannedId: string) {
  await prisma.$transaction([
    prisma.counters.upsert({
      where: { userId: scannerId },
      create: {
        userId: scannerId,
        scanOutCount: 1,
        scanInCount: 0,
      },
      update: {
        scanOutCount: { increment: 1 },
      },
    }),
    prisma.counters.upsert({
      where: { userId: scannedId },
      create: {
        userId: scannedId,
        scanOutCount: 0,
        scanInCount: 1,
      },
      update: {
        scanInCount: { increment: 1 },
      },
    }),
  ]);
}
</file>

<file path="src/lib/repos/profile.ts">
import { prisma } from "@/lib/db";

export async function getProfile(userId: string) {
  const profile = await prisma.profile.findUnique({
    where: { userId },
  });

  return profile ? JSON.parse(profile.profileJson) : null;
}

export async function upsertProfile(userId: string, profileData: any) {
  const profileJson = JSON.stringify(profileData);

  if (profileJson.length > 8192) {
    throw new Error("Profile data too large (max 8KB)");
  }

  return await prisma.profile.upsert({
    where: { userId },
    create: {
      userId,
      profileJson: profileJson,
    },
    update: {
      profileJson: profileJson,
    },
  });
}
</file>

<file path="src/lib/repos/users.ts">
import { prisma } from "@/lib/db";
import crypto from "crypto";

export async function createUser(userId: string, password: string) {
  const passwordHash = crypto.createHash("sha256").update(password).digest("hex");

  return await prisma.user.create({
    data: {
      userId,
      passwordHash,
    },
  });
}

export async function getUserByUserId(userId: string) {
  return await prisma.user.findUnique({
    where: { userId },
  });
}

export async function verifyPassword(userId: string, password: string) {
  const user = await getUserByUserId(userId);
  if (!user) return null;

  const passwordHash = crypto.createHash("sha256").update(password).digest("hex");
  if (user.passwordHash !== passwordHash) return null;

  return user;
}
</file>

<file path="src/lib/session.ts">
import { cookies } from "next/headers";
import crypto from "crypto";

const NAME = "sid";
const MAX_AGE = Number(process.env.SESSION_MAX_AGE_SECONDS || 86400);
const SECRET = process.env.SESSION_SECRET!;

export function issueTicket(userId: string) {
  const exp = Math.floor(Date.now() / 1000) + MAX_AGE;
  const payload = `${userId}.${exp}`;
  const sig = crypto.createHmac("sha256", SECRET).update(payload).digest("hex");
  return `${payload}.${sig}`;
}

export function setSessionCookie(resp: any, userId: string) {
  const ticket = issueTicket(userId);
  resp.cookies.set(NAME, ticket, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    path: "/",
    maxAge: MAX_AGE,
  });
}

export function clearSessionCookie(resp: any) {
  resp.cookies.set(NAME, "", {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    path: "/",
    maxAge: 0,
  });
}

export function requireSession() {
  const raw = cookies().get(NAME)?.value;
  if (!raw) throw new Error("UNAUTH");

  const parts = raw.split(".");
  if (parts.length !== 3) throw new Error("INVALID_FORMAT");

  const [userId, expStr, sig] = parts;
  const exp = Number(expStr);
  const now = Math.floor(Date.now() / 1000);

  if (now > exp) throw new Error("EXPIRED");

  const payload = `${userId}.${exp}`;
  const expected = crypto.createHmac("sha256", SECRET).update(payload).digest("hex");

  if (expected !== sig) throw new Error("BADSIG");

  return { userId };
}
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2020",
    "lib": ["dom", "dom.iterable", "es2020"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="CLAUDE.md">
# CLAUDE.md — POC「高校生向けQRプロフィール×話題提示」実装ガイド

本プロジェクトは **Vercel** へデプロイし、**Gemini**（Google Generative AI）を用いて「話題を1件だけ」生成するWebアプリです。  
開発は **Claude Code**（anthropic/claude-code）でのペアプロ・自動化を想定した手順・タスクを記述します。

---

## 0. プロジェクト要約
- 目的：QR交換 → Geminiが**会話の最初のひと言（1件）**を提示  
- 主要ページ：
  - **ホーム**：自分のQR（大）＋「相手のQRを読み取る」ボタン、話題はモーダル表示  
  - **プロフィール**：トピック→選択肢→任意入力（PUTで全置換）  
  - **実績**：自分の `scanOut / scanIn` 数値のみ  
- 主要API：
  - `POST /api/auth/signup|login|logout`（署名付きCookieセッション）
  - `GET/PUT /api/profile/me`
  - `GET /api/qr/me`（URL＋SVG返却）
  - `POST /api/scan`（30秒クールダウン / message返却）
  - `GET /api/metrics/me`（カウントのみ）
- DBは **User / Profile / Counters** の3表分離設計。  
- クールダウンは **30秒**（本番はKV推奨、開発は in-memory）。

---

## 1. 技術スタック
- **Framework**: Next.js 14（App Router）
- **Runtime**: Node.js 18+（Vercel推奨）
- **DB**: PostgreSQL（Neon または Supabase 無料枠 / Prisma）
- **LLM**: **Gemini 1.5**（Google Generative AI / @google/generative-ai）
- **Auth**: 署名付きCookie（HMAC）
- **QR**: SVG生成（`qrcode`）
- **Cooldown**: Vercel KV（本番推奨） / 開発は in-memory Map
- **UI**: React + Tailwind（推奨）

---

## 2. 環境変数（.env.local）
DATABASE_URL=postgres://...
SESSION_SECRET=ランダム長文字列
SESSION_MAX_AGE_SECONDS=86400
APP_BASE_URL=http://localhost:3000

GOOGLE_GEMINI_API_KEY=xxxxxxxxxxxxxxxx

---

## 3. ディレクトリ構成
```
/src
  /app
    /api
      /auth
        login/route.ts
        logout/route.ts
        signup/route.ts
      /profile/me/route.ts
      /qr/me/route.ts
      /scan/route.ts
      /metrics/me/route.ts
    layout.tsx
    page.tsx
    globals.css
  /lib
    db.ts
    session.ts       # HMAC署名Cookie
    llm.ts           # Gemini呼び出し
    qr.ts            # QR生成
    cooldown.ts      # クールダウン
    repos/
      users.ts
      profile.ts
      counters.ts
  /components
    QrCard.tsx
    TopicModal.tsx
    Toast.tsx
    Navigation.tsx
    CameraScanner.tsx
/prisma
  schema.prisma
package.json
tsconfig.json
next.config.js
tailwind.config.js
postcss.config.js
.env.local
CLAUDE.md

---

## 4. UX設計・画面仕様

### 4.1 ナビゲーション（3タブ）
1. **ホーム（デフォルト）**
   - 上部：自分のQR（大きく表示）
   - 下部：［相手のQRを読み取る］ボタン
   - スキャン成功 → ホーム上にモーダルで話題表示 → ［閉じる］でホームに戻る

2. **プロフィール**
   - トピック（例：音楽、スポーツ、趣味等）→ 選択肢（チェックボックス）
   - 選択時のみ任意の自由入力フィールド表示
   - ［保存］ボタンでPUT全置換

3. **実績**
   - 数値のみシンプル表示：
     - `scanOut`（読んだ回数）
     - `scanIn`（読まれた回数）

### 4.2 読み取り画面
- 全画面カメラビュー
- QR検出 → `POST /api/scan`
- **429（クールダウン）時**：モーダル出さず、**トースト**「時間をおいてトライしてください ⏳」

### 4.3 話題表示
- モーダルで**1件だけ**表示（敬体／1–2文／質問で終える）
- ［閉じる］でホームへ（自分のQRが再び大きく表示）

---

## 5. API仕様詳細

### 5.1 Auth
- `POST /api/auth/signup`
  - Body: `{ userId: string, password: string }`
  - 成功: 200 `{ok:true}` + `Set-Cookie: sid=...`
  - 重複ID: 409 `{error:"user_exists"}`

- `POST /api/auth/login`
  - Body: `{ userId: string, password: string }`
  - 成功: 200 `{ok:true}` + `Set-Cookie: sid=...`
  - 失敗: 401 `{error:"invalid_credentials"}`

- `POST /api/auth/logout`
  - 成功: 200 `{ok:true}`（Cookie破棄）

### 5.2 Profile（認証必須）
- `GET /api/profile/me`
  - 成功: 200 `{...profileJson}`
  - 未作成: 404 or `{}`

- `PUT /api/profile/me`
  - Body: `{ ...profileJson }` （サイズ上限8KB）
  - 成功: 200 `{ok:true}`

### 5.3 QR（認証必須）
- `GET /api/qr/me`
  - 成功: 200 `{ "url": "https://app/scan?sid=<UUID>", "svg": "<svg...>" }`

### 5.4 Scan（認証必須）
- `POST /api/scan`
  - Body: `{ "scannedSid": "<相手User.id(UUID)>" }`
  - 検証：自己スキャン→400、相手不在→404
  - クールダウン30秒→429 `{"error":"cooldown","message":"時間をおいてトライしてください"}`
  - 成功→200 `{ "message": "二人とも音楽が好きみたいですね。最近よく聴く曲はありますか？" }`
  - 副作用：`scanOut++` / `scanIn++`

### 5.5 Metrics（認証必須）
- `GET /api/metrics/me`
  - 成功: 200 `{ "scanOut": number, "scanIn": number }`

### 5.6 共通エラー
| 状態 | HTTP | 返却例 |
|------|-----:|--------|
| 未ログイン | 401 | `{"error":"unauthorized"}` |
| 自己スキャン | 400 | `{"error":"self_scan"}` |
| 相手不在 | 404 | `{"error":"user_not_found"}` |
| クールダウン | 429 | `{"error":"cooldown","message":"時間をおいてトライしてください"}` |
| 予期せぬ | 500 | `{"error":"internal"}` |

---

## 6. Prisma スキーマ
```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  userId       String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  profile      Profile?
  counters     Counters?
}

model Profile {
  userId      String   @id
  profileJson Json
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Counters {
  userId        String   @id
  scanOutCount  Int      @default(0)
  scanInCount   Int      @default(0)
  updatedAt     DateTime @updatedAt

  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}
```

---

## 5. セッション（HMAC署名付きCookie）
```ts
// lib/session.ts
import { cookies } from "next/headers";
import crypto from "crypto";

const NAME = "sid";
const MAX_AGE = Number(process.env.SESSION_MAX_AGE_SECONDS || 86400);
const SECRET = process.env.SESSION_SECRET!;

export function issueTicket(userId: string) {
  const exp = Math.floor(Date.now() / 1000) + MAX_AGE;
  const payload = `${userId}.${exp}`;
  const sig = crypto.createHmac("sha256", SECRET).update(payload).digest("hex");
  return `${payload}.${sig}`;
}

export function setSessionCookie(resp: any, userId: string) {
  const ticket = issueTicket(userId);
  resp.cookies.set(NAME, ticket, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    path: "/",
    maxAge: MAX_AGE,
  });
}

export function requireSession() {
  const raw = cookies().get(NAME)?.value;
  if (!raw) throw new Error("UNAUTH");
  const [userId, expStr, sig] = raw.split(".");
  const exp = Number(expStr);
  const now = Math.floor(Date.now() / 1000);
  if (now > exp) throw new Error("EXPIRED");
  const payload = `${userId}.${exp}`;
  const expect = crypto.createHmac("sha256", SECRET).update(payload).digest("hex");
  if (expect !== sig) throw new Error("BADSIG");
  return { userId };
}
```

---

## 6. クールダウン実装
```ts
// lib/cooldown.ts
let mem = new Map<string, number>();
const WINDOW = 30_000;

export async function canScan(scannerId: string, scannedId: string) {
  const key = `${scannerId}:${scannedId}`;
  const now = Date.now();
  const last = mem.get(key) ?? 0;
  if (now - last < WINDOW) return { ok: false, waitMs: WINDOW - (now - last) };
  mem.set(key, now);
  return { ok: true };
}
```

---

## 7. Gemini 呼び出し
```ts
// lib/llm.ts
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_GEMINI_API_KEY!);
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

const SYSTEM = `あなたは高校生の初対面の会話を助けるアシスタントです。
安全第一（政治/宗教/性/病気/金銭/個人特定は扱わない）。
出力は敬体で1〜2文、最後は質問で終える。出力は1件のみ。`;

export async function generateTopic(profileA: any, profileB: any): Promise<string> {
  try {
    const prompt = [
      { role: "user", parts: [{ text: SYSTEM }] },
      { role: "user", parts: [{ text: `A=${JSON.stringify(profileA)}\nB=${JSON.stringify(profileB)}\n出力は {"message":"..."} 形式で。`} ] },
    ];
    const res = await model.generateContent({ contents: prompt });
    const msg = JSON.parse(res.response.text().trim()).message;
    return msg;
  } catch {
    return "音楽はよく聴きますか？最近のお気に入りがあれば教えてください。";
  }
}
```

---

## 8. API サンプル

### QR
```ts
// app/api/qr/me/route.ts
import { NextResponse } from "next/server";
import { requireSession } from "@/lib/session";
import QRCode from "qrcode";

export async function GET() {
  const me = requireSession();
  const url = `${process.env.APP_BASE_URL}/scan?sid=${me.userId}`;
  const svg = await QRCode.toString(url, { type: "svg", errorCorrectionLevel: "M", margin: 0 });
  return NextResponse.json({ url, svg });
}
```

### スキャン
```ts
// app/api/scan/route.ts
import { NextResponse } from "next/server";
import { requireSession } from "@/lib/session";
import { prisma } from "@/lib/db";
import { getProfile } from "@/lib/repos/profile";
import { incrScanOutIn } from "@/lib/repos/counters";
import { generateTopic } from "@/lib/llm";
import { canScan } from "@/lib/cooldown";

export async function POST(req: Request) {
  try {
    const me = requireSession();
    const { scannedSid } = await req.json();
    if (!scannedSid) return NextResponse.json({ error: "bad_request" }, { status: 400 });
    if (me.userId === scannedSid) return NextResponse.json({ error: "self_scan" }, { status: 400 });

    const scanned = await prisma.user.findUnique({ where: { id: scannedSid } });
    if (!scanned) return NextResponse.json({ error: "user_not_found" }, { status: 404 });

    const cd = await canScan(me.userId, scanned.id);
    if (!cd.ok) return NextResponse.json({ error: "cooldown", message: "時間をおいてトライしてください" }, { status: 429 });

    const [pa, pb] = await Promise.all([getProfile(me.userId), getProfile(scanned.id)]);
    const message = await generateTopic(pa ?? {}, pb ?? {});
    await incrScanOutIn(me.userId, scanned.id);

    return NextResponse.json({ message });
  } catch {
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
```

### 実績
```ts
// app/api/metrics/me/route.ts
import { NextResponse } from "next/server";
import { requireSession } from "@/lib/session";
import { prisma } from "@/lib/db";

export async function GET() {
  const me = requireSession();
  const c = await prisma.counters.findUnique({ where: { userId: me.userId } });
  return NextResponse.json({
    scanOut: c?.scanOutCount ?? 0,
    scanIn:  c?.scanInCount  ?? 0,
  });
}
```

---

## 9. テスト観点（POC）
- ログイン/ログアウト：Cookie属性確認  
- プロフィール：GET空→PUT保存→GET反映  
- QR：URL＋SVGが返却されること  
- スキャン：正常／自己／相手不在／クールダウン  
- LLM：JSON形式の返却、失敗時はフォールバック  
- 実績：カウントが正しく増加  

---

## 10. 実装状況と順序

### ✅ 実装完了済み（バックエンド）：
1. **基盤設定**
   - Next.js 14プロジェクト初期化
   - Prisma設定とスキーマ定義（PostgreSQL対応）
   - TypeScript設定（target: es2020）
   - Tailwind CSS設定

2. **認証システム** (署名付きCookie)
   - `lib/session.ts` - HMAC署名付きCookie
   - `lib/repos/users.ts` - ユーザー管理
   - `api/auth/signup` - 新規登録
   - `api/auth/login` - ログイン
   - `api/auth/logout` - ログアウト

3. **プロフィール機能**
   - `lib/repos/profile.ts` - プロフィール管理（String型でJSON保存）
   - `api/profile/me` - GET/PUT エンドポイント

4. **QR生成・表示**
   - `lib/qr.ts` - SVG QRコード生成
   - `api/qr/me` - QR生成エンドポイント

5. **スキャン・話題提示**（核心機能）
   - `lib/cooldown.ts` - 30秒クールダウン
   - `lib/llm.ts` - Gemini連携
   - `lib/repos/counters.ts` - カウンター管理
   - `api/scan` - スキャン処理エンドポイント

6. **実績表示**
   - `api/metrics/me` - 実績取得エンドポイント

### ✅ 実装完了済み（フロントエンド）：
1. **認証画面**
   - `/auth/signup` - 新規登録画面
   - `/auth/login` - ログイン画面
   - 認証後のリダイレクト処理

2. **メイン画面**
   - `/home` - QR表示・スキャン機能
   - `/profile` - プロフィール編集
   - `/metrics` - 実績表示

3. **共通コンポーネント**
   - `Navigation.tsx` - 3タブナビゲーション
   - `TopicModal.tsx` - 話題表示モーダル
   - `Toast.tsx` - エラー/通知トースト
   - `CameraScanner.tsx` - QRスキャナー

### ✅ Vercelデプロイ対応：
- **動的実行設定**: 全APIルートに `export const dynamic = 'force-dynamic'` 追加
- **環境変数ドキュメント**: DEPLOYMENT_FIX.md作成
- **本番環境での動作確認済み**

### 📝 修正済み設計変更：
- **Middleware削除**: Edge環境でのnext/headers互換性問題により、各APIハンドラでの認証チェックに統一
- **QR画像サイズ**: SVGの拡大縮小特性を活かすためwidth固定指定を削除
- **Profile.profileJson型**: PostgreSQLとの互換性のためString型で保持（JSON.parse/stringifyで処理）
- **動的レンダリング強制**: cookies()使用によるビルドエラー対策

### 🎉 POC完成状態：
現在、全機能が実装済みでVercelデプロイも成功。以下が動作確認済み：
- ユーザー登録・ログイン
- プロフィール保存・取得
- QRコード生成・表示
- スキャン・話題生成（Gemini連携）
- 実績カウント表示
- 30秒クールダウン機能

---

## 11. 受け入れ条件（POC Done）
20–30人規模テストで：
- ログイン・プロフィール保存成功率 ≥ 90%
- スキャン→話題表示の成功率 ≥ 85%、平均応答 ≤ 1.5s
- アンケート：「会話を始めやすくなった」**≥ 70%**
- クールダウン中は 429 とトーストが正しく表示

---

## 12. デプロイ手順（Vercel）

### 必須環境変数
1. **DATABASE_URL** - PostgreSQL接続文字列（Supabase/Neon）
2. **SESSION_SECRET** - ランダムな32文字以上の文字列
3. **APP_BASE_URL** - 本番URL（例: https://your-app.vercel.app）
4. **GOOGLE_GEMINI_API_KEY** - Gemini APIキー
5. **SESSION_MAX_AGE_SECONDS** - セッション有効期限（デフォルト: 86400）

### デプロイ確認事項
- ✅ 全APIルートに `export const dynamic = 'force-dynamic'` 設定済み
- ✅ Prismaビルド時に `prisma generate` 実行（package.jsonのbuildスクリプトで対応済み）
- ✅ PostgreSQL（Supabase）との接続確認済み
- ✅ HTTPS環境での動作確認済み

---

## 13. 開発環境セットアップ手順

### 前提条件
- Node.js 18+
- PostgreSQL データベース（Supabase推奨）
- Gemini API キー

### セットアップ
```bash
# 依存関係インストール
npm install

# 環境変数設定
cp .env.local.example .env.local
# DATABASE_URL, SESSION_SECRET, GOOGLE_GEMINI_API_KEY を設定

# Prismaクライアント生成
npx prisma generate

# データベースマイグレーション（本番環境）
npx prisma db push

# 開発サーバー起動
npm run dev
```

### APIテスト例
```bash
# 新規登録
curl -X POST http://localhost:3000/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{"userId":"test1","password":"password123"}'

# QR取得
curl -X GET http://localhost:3000/api/qr/me \
  -H "Cookie: sid=<session_cookie>"
```
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {};

module.exports = nextConfig;
</file>

<file path="src/app/api/auth/login/route.ts">
// Force dynamic execution (required for cookies)
export const dynamic = 'force-dynamic';
export const revalidate = 0;

import { NextRequest, NextResponse } from "next/server";
import { verifyPassword } from "@/lib/repos/users";
import { setSessionCookie } from "@/lib/session";

export async function POST(req: NextRequest) {
  try {
    const { userId, password } = await req.json();

    if (!userId || !password) {
      return NextResponse.json({ error: "bad_request" }, { status: 400 });
    }

    const user = await verifyPassword(userId, password);
    if (!user) {
      return NextResponse.json({ error: "invalid_credentials" }, { status: 401 });
    }

    const response = NextResponse.json({ ok: true });
    setSessionCookie(response, user.id);

    return response;
  } catch (error) {
    console.error("Login error:", error);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/logout/route.ts">
// Force dynamic execution (required for cookies)
export const dynamic = 'force-dynamic';
export const revalidate = 0;

import { NextRequest, NextResponse } from "next/server";
import { clearSessionCookie } from "@/lib/session";

export async function POST(req: NextRequest) {
  try {
    const response = NextResponse.json({ ok: true });
    clearSessionCookie(response);
    return response;
  } catch (error) {
    console.error("Logout error:", error);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/signup/route.ts">
// Force dynamic execution (required for cookies)
export const dynamic = 'force-dynamic';
export const revalidate = 0;

import { NextRequest, NextResponse } from "next/server";
import { createUser, getUserByUserId } from "@/lib/repos/users";
import { setSessionCookie } from "@/lib/session";

export async function POST(req: NextRequest) {
  try {
    const { userId, password } = await req.json();

    if (!userId || !password) {
      return NextResponse.json({ error: "bad_request" }, { status: 400 });
    }

    const existingUser = await getUserByUserId(userId);
    if (existingUser) {
      return NextResponse.json({ error: "user_exists" }, { status: 409 });
    }

    const user = await createUser(userId, password);

    const response = NextResponse.json({ ok: true });
    setSessionCookie(response, user.id);

    return response;
  } catch (error) {
    console.error("Signup error:", error);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/metrics/me/route.ts">
// Force dynamic execution (required for cookies)
export const dynamic = 'force-dynamic';
export const revalidate = 0;

import { NextResponse } from "next/server";
import { requireSession } from "@/lib/session";
import { getCounters } from "@/lib/repos/counters";

export async function GET() {
  try {
    const { userId } = requireSession();
    const counters = await getCounters(userId);

    return NextResponse.json({
      scanOut: counters.scanOut,
      scanIn: counters.scanIn,
    });
  } catch (error: any) {
    if (error.message === "UNAUTH" || error.message === "EXPIRED" || error.message === "BADSIG") {
      return NextResponse.json({ error: "unauthorized" }, { status: 401 });
    }
    console.error("Get metrics error:", error);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/profile/me/route.ts">
// Force dynamic execution (required for cookies)
export const dynamic = 'force-dynamic';
export const revalidate = 0;

import { NextRequest, NextResponse } from "next/server";
import { requireSession } from "@/lib/session";
import { getProfile, upsertProfile } from "@/lib/repos/profile";

export async function GET() {
  try {
    const { userId } = requireSession();
    const profile = await getProfile(userId);

    if (!profile) {
      return NextResponse.json({}, { status: 200 });
    }

    return NextResponse.json(profile);
  } catch (error: any) {
    if (error.message === "UNAUTH" || error.message === "EXPIRED" || error.message === "BADSIG") {
      return NextResponse.json({ error: "unauthorized" }, { status: 401 });
    }
    console.error("Get profile error:", error);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}

export async function PUT(req: NextRequest) {
  try {
    const { userId } = requireSession();
    const profileData = await req.json();

    await upsertProfile(userId, profileData);

    return NextResponse.json({ ok: true });
  } catch (error: any) {
    if (error.message === "UNAUTH" || error.message === "EXPIRED" || error.message === "BADSIG") {
      return NextResponse.json({ error: "unauthorized" }, { status: 401 });
    }
    if (error.message.includes("Profile data too large")) {
      return NextResponse.json({ error: "profile_too_large" }, { status: 400 });
    }
    console.error("Update profile error:", error);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/qr/me/route.ts">
// Force dynamic execution (required for cookies)
export const dynamic = 'force-dynamic';
export const revalidate = 0;

import { NextResponse } from "next/server";
import { requireSession } from "@/lib/session";
import { generateQR } from "@/lib/qr";

export async function GET() {
  try {
    const { userId } = requireSession();
    const url = `${process.env.APP_BASE_URL}/scan?sid=${userId}`;
    const svg = await generateQR(url);

    return NextResponse.json({ url, svg });
  } catch (error: any) {
    if (error.message === "UNAUTH" || error.message === "EXPIRED" || error.message === "BADSIG") {
      return NextResponse.json({ error: "unauthorized" }, { status: 401 });
    }
    console.error("QR generation error:", error);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/scan/route.ts">
// Force dynamic execution (required for cookies)
export const dynamic = 'force-dynamic';
export const revalidate = 0;

import { NextRequest, NextResponse } from "next/server";
import { requireSession } from "@/lib/session";
import { prisma } from "@/lib/db";
import { getProfile } from "@/lib/repos/profile";
import { incrScanOutIn } from "@/lib/repos/counters";
import { generateTopic } from "@/lib/llm";
import { canScan } from "@/lib/cooldown";

export async function POST(req: NextRequest) {
  try {
    const { userId: scannerId } = requireSession();
    const { scannedSid } = await req.json();

    if (!scannedSid) {
      return NextResponse.json({ error: "bad_request" }, { status: 400 });
    }

    if (scannerId === scannedSid) {
      return NextResponse.json({ error: "self_scan" }, { status: 400 });
    }

    const scannedUser = await prisma.user.findUnique({
      where: { id: scannedSid },
    });

    if (!scannedUser) {
      return NextResponse.json({ error: "user_not_found" }, { status: 404 });
    }

    const cd = await canScan(scannerId, scannedUser.id);
    if (!cd.ok) {
      return NextResponse.json({
        error: "cooldown",
        message: "時間をおいてトライしてください"
      }, { status: 429 });
    }

    const [profileA, profileB] = await Promise.all([
      getProfile(scannerId),
      getProfile(scannedUser.id),
    ]);

    const message = await generateTopic(profileA ?? {}, profileB ?? {});

    await incrScanOutIn(scannerId, scannedUser.id);

    return NextResponse.json({ message });
  } catch (error: any) {
    if (error.message === "UNAUTH" || error.message === "EXPIRED" || error.message === "BADSIG") {
      return NextResponse.json({ error: "unauthorized" }, { status: 401 });
    }
    console.error("Scan error:", error);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  userId       String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  profile      Profile?
  counters     Counters?
}

model Profile {
  userId      String   @id
  profileJson String
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Counters {
  userId        String   @id
  scanOutCount  Int      @default(0)
  scanInCount   Int      @default(0)
  updatedAt     DateTime @updatedAt

  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}
</file>

<file path="package.json">
{
  "name": "propose-conversation-topic",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "prisma generate && next build",
    "start": "next start",
    "lint": "next lint",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  },
  "dependencies": {
    "@google/generative-ai": "^0.21.0",
    "@prisma/client": "^5.19.1",
    "@yudiel/react-qr-scanner": "^2.3.1",
    "autoprefixer": "^10.4.21",
    "next": "14.2.12",
    "qrcode": "^1.5.4",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/node": "^20.16.5",
    "@types/qrcode": "^1.5.5",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "eslint": "^8.57.0",
    "eslint-config-next": "14.2.12",
    "postcss": "^8.4.45",
    "prisma": "^5.19.1",
    "tailwindcss": "^3.4.10",
    "typescript": "^5.6.2"
  }
}
</file>

</files>
